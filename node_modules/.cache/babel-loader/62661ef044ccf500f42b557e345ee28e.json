{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _SIDES = require('./SIDES');\n\nvar _SIDES2 = _interopRequireDefault(_SIDES);\n\nvar _Item = require('./Item/Item');\n\nvar _Item2 = _interopRequireDefault(_Item);\n\nvar _swipeReact = require('swipe-react');\n\nvar _swipeReact2 = _interopRequireDefault(_swipeReact);\n\nvar _wheelReact = require('wheel-react');\n\nvar _wheelReact2 = _interopRequireDefault(_wheelReact);\n\nvar _arrowKeysReact = require('arrow-keys-react');\n\nvar _arrowKeysReact2 = _interopRequireDefault(_arrowKeysReact);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar Container = function (_React$Component) {\n  _inherits(Container, _React$Component);\n\n  function Container(props) {\n    _classCallCheck(this, Container);\n\n    var _this = _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).call(this, props));\n\n    _this.selectItem = _this.selectItem.bind(_this);\n    _this.prepareItems = _this.prepareItems.bind(_this);\n    _this.calcIndex = _this.calcIndex.bind(_this);\n    _this.calcItemDimensions = _this.calcItemDimensions.bind(_this);\n    _this.calcItemsAmountToRender = _this.calcItemsAmountToRender.bind(_this);\n\n    var index = _this.calcIndex();\n\n    _this.state = {\n      selectedIndex: index,\n      prevIndex: index,\n      pauseWheelEvent: false\n    };\n\n    var next = function next() {\n      var index = _this.state.selectedIndex;\n\n      if (index + 1 < _this.props.imagesArr.length) {\n        _this.selectItem(index + 1);\n      }\n    };\n\n    var previous = function previous() {\n      var index = _this.state.selectedIndex;\n\n      if (index > 0) {\n        _this.selectItem(index - 1);\n      }\n    };\n\n    var keysConfig = {\n      left: previous,\n      right: next,\n      up: next,\n      down: previous\n    };\n    var touchConfig = {\n      left: next,\n      right: previous,\n      up: next,\n      down: previous\n    };\n\n    _swipeReact2.default.config(touchConfig);\n\n    _wheelReact2.default.config(touchConfig);\n\n    _arrowKeysReact2.default.config(keysConfig);\n\n    return _this;\n  }\n\n  _createClass(Container, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var itemWidth = void 0,\n          itemHeight = void 0;\n\n      var _calcItemDimensions = this.calcItemDimensions();\n\n      var _calcItemDimensions2 = _slicedToArray(_calcItemDimensions, 2);\n\n      itemWidth = _calcItemDimensions2[0];\n      itemHeight = _calcItemDimensions2[1];\n      var items = this.prepareItems();\n      return _react2.default.createElement('div', _extends({\n        tabIndex: '0',\n        style: this.props.containerStyles\n      }, _swipeReact2.default.events, _wheelReact2.default.events, _arrowKeysReact2.default.events, {\n        ref: function ref(coverflow) {\n          _this2.coverflow = coverflow;\n        }\n      }), items.map(function (item) {\n        return _react2.default.createElement(_Item2.default, {\n          side: item.side,\n          max: Math.floor(_this2.calcItemsAmountToRender() / 2),\n          distance: item.distance,\n          imgUrl: item.imgUrl,\n          selectItem: _this2.selectItem,\n          index: item.index,\n          zIndex: _this2.props.zIndex,\n          height: itemHeight,\n          width: itemWidth,\n          label: item.label,\n          direction: _this2.props.direction,\n          key: item.index\n        });\n      }));\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.coverflow.focus();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      _wheelReact2.default.clearTimeout();\n    }\n  }, {\n    key: 'selectItem',\n    value: function selectItem(index) {\n      this.setState(function (prevState) {\n        return {\n          selectedIndex: index,\n          prevIndex: prevState.selectedIndex\n        };\n      });\n\n      if (this.props.handleSelect) {\n        this.props.handleSelect(index);\n      }\n    }\n  }, {\n    key: 'prepareItems',\n    value: function prepareItems() {\n      if (this.props.imagesArr.length === 0) {\n        return [];\n      }\n\n      var AMOUNT_TO_RENDER = this.calcItemsAmountToRender();\n      var SIDE_AMOUNT = Math.floor(AMOUNT_TO_RENDER / 2);\n      var index = this.state.selectedIndex;\n      var imagesArr = JSON.parse(JSON.stringify(this.props.imagesArr));\n      var items = imagesArr.map(function (imgUrl, index) {\n        return {\n          imgUrl: imgUrl,\n          index: index,\n          label: null\n        };\n      });\n\n      for (var i = 0; i < this.props.labelsArr.length; i++) {\n        items[i].label = this.props.labelsArr[i];\n      }\n\n      items[index].side = _SIDES2.default.CENTER;\n      items[index].distance = 0;\n      var fromIndex = Math.max(0, index - SIDE_AMOUNT);\n      var untilIndex = Math.min(imagesArr.length, index + SIDE_AMOUNT + 1);\n\n      for (var _i = fromIndex; _i < index; _i++) {\n        items[_i].side = _SIDES2.default.LEFT;\n        items[_i].distance = index - _i;\n      }\n\n      for (var _i2 = index + 1; _i2 < untilIndex; _i2++) {\n        items[_i2].side = _SIDES2.default.RIGHT;\n        items[_i2].distance = _i2 - index;\n      }\n\n      if (items.length < AMOUNT_TO_RENDER) {\n        return items;\n      } // calc removed items, in order to animate them.\n\n\n      var amount = index - this.state.prevIndex;\n\n      if (amount > 0 && fromIndex > SIDE_AMOUNT) {\n        for (var _i3 = fromIndex - amount; _i3 < fromIndex; _i3++) {\n          items[_i3].side = _SIDES2.default.REMOVED_LEFT;\n          items[_i3].distance = index - _i3;\n        }\n\n        fromIndex -= amount;\n      } else if (amount < 0) {\n        amount *= -1;\n\n        if (untilIndex + amount < items.length) {\n          for (var _i4 = untilIndex; _i4 < untilIndex + amount; _i4++) {\n            if (!items[_i4]) {\n              debugger;\n            }\n\n            items[_i4].side = _SIDES2.default.REMOVED_RIGHT;\n            items[_i4].distance = _i4 - index;\n          }\n\n          untilIndex += amount;\n        }\n      }\n\n      return items.slice(fromIndex, untilIndex);\n    }\n  }, {\n    key: 'calcIndex',\n    value: function calcIndex() {\n      var length = this.props.imagesArr.length;\n\n      if (length === 0) {\n        return -1;\n      }\n\n      if (length > 10) {\n        return 5;\n      }\n\n      return parseInt(this.props.imagesArr.length / 2, 10);\n    }\n  }, {\n    key: 'calcItemDimensions',\n    value: function calcItemDimensions() {\n      var ratio = {};\n\n      var _props$itemRatio$spli = this.props.itemRatio.split(':').map(function (x) {\n        return parseFloat(x);\n      });\n\n      var _props$itemRatio$spli2 = _slicedToArray(_props$itemRatio$spli, 2);\n\n      ratio.x = _props$itemRatio$spli2[0];\n      ratio.y = _props$itemRatio$spli2[1];\n      var itemWidth = void 0,\n          itemHeight = void 0;\n\n      if (this.props.direction === 'vertical') {\n        itemWidth = this.props.width - 70;\n        itemHeight = itemWidth * ratio.y / ratio.x;\n      } else {\n        itemHeight = this.props.height - 60;\n        itemWidth = itemHeight * ratio.x / ratio.y;\n      }\n\n      return [itemWidth, itemHeight];\n    }\n  }, {\n    key: 'calcItemsAmountToRender',\n    value: function calcItemsAmountToRender() {\n      var amount = void 0;\n\n      if (this.props.direction === 'vertical') {\n        var containerHeight = this.props.height;\n        var itemHeight = void 0;\n\n        var _calcItemDimensions3 = this.calcItemDimensions();\n\n        var _calcItemDimensions4 = _slicedToArray(_calcItemDimensions3, 2);\n\n        itemHeight = _calcItemDimensions4[1];\n        amount = Math.floor(containerHeight / itemHeight) * 2 - 4;\n      } else {\n        var containerWidth = this.props.width;\n        var itemWidth = void 0;\n\n        var _calcItemDimensions5 = this.calcItemDimensions();\n\n        var _calcItemDimensions6 = _slicedToArray(_calcItemDimensions5, 1);\n\n        itemWidth = _calcItemDimensions6[0];\n        amount = Math.floor(containerWidth / itemWidth) * 2 - 3;\n      }\n\n      if (amount < 3) {\n        amount = 3;\n      } else if (amount > 11) {\n        amount = 11;\n      }\n\n      return Math.min(amount, this.props.imagesArr.length);\n    }\n  }]);\n\n  return Container;\n}(_react2.default.Component);\n\nContainer.propTypes = {\n  imagesArr: _propTypes2.default.array.isRequired,\n  zIndex: _propTypes2.default.number,\n  height: _propTypes2.default.number,\n  background: _propTypes2.default.string,\n  border: _propTypes2.default.string,\n  boxShadow: _propTypes2.default.string,\n  itemRatio: _propTypes2.default.string,\n  handleSelect: _propTypes2.default.func\n};\nexports.default = Container;","map":null,"metadata":{},"sourceType":"script"}